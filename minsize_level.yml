- title: Config
  content: |
    // MDA::Config initialization list
    MDA::Config {
      "minsize_level",
      "aggregated upto finding <min_lots> as quantity",
      { // parameter configuration
        //{ "<name>", { "<description>", <type>, "<default_value>" } }
          {   pmin_lots, { "number of lots <min_lots> (<min_lots> > 0)", Parameter::Type::Int32, "1" } },
          { pTimeBin, { "in minutes bins the results into buckets (minimal value is 1 minute; max value is 60 minutes)", Parameter::Type::Int64, "1" } }
      },
      { // result configuration
        { "message",
          "message",
          ResultSet::Type::Value,
          {
            // { "<name>", "<description>", <type> },
            { "text", "error message", Result::Type::String }
          }
        },
        { "bid",
          "bid",
          ResultSet::Type::Series,
          {
            // { "<name>", "<description>", <type> },
            { "ts", "timestamp", Result::Type::Timestamp },
            { "price", "price", Result::Type::Double }
          }
        },
        { "ask",
          "ask",
          ResultSet::Type::Series,
          {
            // { "<name>", "<description>", <type> },
            { "ts", "timestamp", Result::Type::Timestamp },
            { "price", "price", Result::Type::Double }
          }
        }
      }
    }
    
    
    
    
    
- title: Context.h
  content: |
    #include <eobi/EobiUtil.h>
    #include <util/novalue.h>
    // you may add additional includes here, as this is the only place you may do so
    
    // parameter titles
    static constexpr const char* const pmin_lots = "min_lots";
    static constexpr const char* const pTimeBin = "aggr";
    
    #define ADD_RES(member)                                                \
    if (context.ts ## member [0] == context.ts ## member [1]) {                \
      addResult ## member(context.ts ## member[0], context.v ## member[0] != noValue<double>() ? context.v ## member[0] / 100000000.0 : noValue<double>()); \
    } else if(context.ts ## member[0] < context.ts ## member[1]) {             \
      addResult ## member(context.ts ## member[0], context.v ## member[0] != noValue<double>() ? context.v ## member[0] / 100000000.0 : noValue<double>()); \
      addResult ## member(context.ts ## member[1], context.v ## member[1] != noValue<double>() ? context.v ## member[1] / 100000000.0 : noValue<double>()); \
      context.ts ## member[0] = context.ts ## member[1];                       \
    } else {                                                                   \
      addResult ## member(context.ts ## member[1], context.v ## member[1] != noValue<double>() ? context.v ## member[1] / 100000000.0 : noValue<double>()); \
      addResult ## member(context.ts ## member[0], context.v ## member[0] != noValue<double>() ? context.v ## member[0] / 100000000.0 : noValue<double>()); \
      context.ts ## member[1] = context.ts ## member[0];                       \
    }
    
    #define CATCH_CONVERTION_ERROR(pn,p)                                                                    			   \
    catch (const std::invalid_argument& ia) {                                                            				   \
      if (context.sMessage.size() > 0) context.sMessage.append(" ");                                                       \
      context.sMessage.append("Invalid argument exception when parsing ").append(pn).append(" \'").append(p).append("\'"); \
      setResultmessage(context.sMessage);                                                                                  \
    }                                                                                                       			   \
    catch (const std::out_of_range& oor) {                                                                  			   \
      if (context.sMessage.size() > 0) context.sMessage.append(" ");                                                       \
      context.sMessage.append("Out-of-range exception when parsing ").append(pn).append(" \'").append(p).append("\'");     \
      setResultmessage(context.sMessage);                                                                                  \
    }
    
    /**
     * This is the place, you may store intermediary values for your calculation.
     *  The same Context object will be available in _every_ callback
     */
    struct Context {
        // please take care of constructing/destroying your structures with care,
        // as this directly affects your performance
      Context()
        : min_lots(1), tb(60000000000UL), ts(0)
      , tsbid{ 0, 0 }, tsask{ 0, 0 }, vbid{ noValue<double>(), noValue<double>() }, vask{ noValue<double>(), noValue<double>() }
      , sMessage("")
      {}
      
    public:
      uint16_t min_lots;
      uint64_t tb;
      
      uint64_t ts;
      uint64_t tsbid[2];
      uint64_t tsask[2];
      float_t vbid[2];
      float_t vask[2];
      //int64_t
      std::string sMessage;
    };
    
    
    
    
    
- title: onComplete
  content: |
    // for information about the data structures please consult the T7 EOBI Market data Interface Manual
    // note: code completion help is accessible with <Ctrl><Space>
    // bool on Complete(const MDA::AlgoBase::Key& key, const Complete& obj, Context& context) {
        // place add your code here
    
    if (context.vbid[0] != noValue<double>() || context.vbid[1] != noValue<double>() || context.vask[0] != noValue<double>() || context.vask[1] != noValue<double>()) {
      ADD_RES(bid)
      ADD_RES(ask)
    }
    
        // return true;
    //}
    
    
    
    
    
- title: onOrderbook
  content: |
    // for information about the data structures please consult the T7 EOBI Market data Interface Manual
    // note: code completion help is accessible with <Ctrl><Space>
    // bool on Orderbook(const MDA::AlgoBase::Key& key, const Orderbook& obj, Context& context) {
        // place add your code here
    
    if(context.ts != 0) {
      if(context.ts < obj.ts) {
        ADD_RES(bid)
        ADD_RES(ask)
        context.vbid[0] = context.vbid[1] = context.vask[0] = context.vask[1] = noValue<double>();
        context.ts = context.tb + obj.ts;
      }
    } else context.ts = context.tb + obj.ts;
    
    // namespace Eobi {
    //   using Market				= std::string;
    //   using MarketSegmentID		= int32_t;
    //   using SecurityID			= int64_t;
    //   using Timestamp			= uint64_t;	
    //   using Price				= int64_t;
    //   using InstrProductComplex	= uint8_t;
    //
    //   typedef std::vector<Trade> TradeList;
    //
    //   class Orderbook {
    //     typedef std::map<Price, min_lots*, std::greater<Price> > BidMap;
    //     typedef std::map<Price, min_lots*, std::less   <Price> > AskMap;
    //   }
    // }
    
    const Eobi::Orderbook::BidMap& bids = obj.getBids();
    const Eobi::Orderbook::AskMap& asks = obj.getAsks();
    // const Eobi::TradeList& trades = obj.getTrades();
    
    float bid = 0;
    int64_t bidsize = 0;
    float this_bid = 0;
    int64_t this_bidsize = 0;
    float ask = 0;
    int64_t asksize = 0;
    float this_ask = 0;
    int64_t this_asksize = 0;
    
    uint16_t min_lots = context.min_lots;
    auto it_bids = bids.cbegin();
    while (it_bids != bids.cend()) {
      this_bid = it_bids->first;
      this_bidsize = it_bids->second->qty();
      this_bidsize = std::min(this_bidsize, min_lots * 10000 - bidsize);
      bid = (bid*bidsize + this_bid*this_bidsize) / (bidsize + this_bidsize);
      bidsize += this_bidsize;
      if (bidsize < min_lots * 10000) ++it_bids; else break;
    }
    if (bidsize < min_lots * 10000) {
      bid = 0; }
    
    
    auto it_asks = asks.cbegin();
    while (it_asks != asks.cend()) {
      this_ask = it_asks->first;
      this_asksize = it_asks->second->qty();
      this_asksize = std::min(this_asksize, min_lots * 10000 - asksize);
      ask = (ask*asksize + this_ask*this_asksize) / (asksize + this_asksize);
      asksize += this_asksize;
      if (asksize < min_lots * 10000) ++it_asks; else break;
    }
    if (asksize < min_lots * 10000) {
      ask = 0; }
    
    if(context.vbid[0] == noValue<double>() || bid < context.vbid[0]) {
      context.tsbid[0] = obj.ts;
      context.vbid[0] = bid;
    }
    if(context.vbid[1] == noValue<double>() || bid > context.vbid[1]) {
      context.tsbid[1] = obj.ts;
      context.vbid[1] = bid;
    }
    
    if(context.vask[0] == noValue<double>() || ask < context.vask[0]) {
      context.tsask[0] = obj.ts;
      context.vask[0] = ask;
    }
    if(context.vask[1] == noValue<double>() || ask > context.vask[1]) {
      context.tsask[1] = obj.ts;
      context.vask[1] = ask;
    }
    
        // return true;
    //}
    
    
    
    
    
- title: onSetParameter
  content: |
    //bool onSetParameter(const Parameters& param, Context& context) {
        // process all parameters from the params map<std::string std::string> here
    
    std::map<std::string,std::string>::const_iterator ii_min_lots = params.find(pmin_lots);
    if (ii_min_lots != params.cend()) {
      try{
        context.min_lots = (uint16_t)std::stoi(ii_min_lots->second);
        if (context.min_lots < 1) context.min_lots = 1;
      }
      CATCH_CONVERTION_ERROR(pmin_lots,ii_min_lots->second)
    }
    
    std::map<std::string,std::string>::const_iterator ii_timeBin = params.find(pTimeBin);
    if (ii_timeBin != params.cend()) {
      try{
        context.tb = std::stoull(ii_timeBin->second) * 60000000000UL;
        if (context.tb < 60000000000UL) context.tb = 60000000000UL; else if (context.tb > 3600000000000UL) context.tb = 3600000000000UL;
      }
      CATCH_CONVERTION_ERROR(pTimeBin,ii_timeBin->second)
    }
    
        //  return true;
    //}
    
    
    
    
